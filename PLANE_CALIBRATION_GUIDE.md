# A4 평면 좌표계 캘리브레이션 가이드

## 📐 개요

카메라로 A4 용지의 **평면 좌표**를 정확하게 측정하기 위해 **3점 기준점**을 사용하는 방법입니다.

## 🎯 왜 3점이 필요한가?

### 1. **평면 정의**
- 3점은 하나의 평면을 고유하게 정의합니다
- 2D 평면에서 좌표계를 만들기 위한 최소 요구사항

### 2. **Affine 변환**
- 픽셀 좌표 → 실제 물리 좌표 변환
- 회전, 스케일, 이동을 모두 보정

### 3. **X축이 같다는 것을 확인**
- 3점으로 정의된 좌표계에서는 **동일한 X값**을 가진 점들이 **같은 선상**에 위치

## 🔧 3점 캘리브레이션 방법

### 설정된 기준점

```python
REFERENCE_POINTS_M = {
    'origin': (0.0, 0.0),           # 원점 (왼쪽 아래)
    'x_axis': (0.210, 0.0),         # X축 정의점 (오른쪽 아래, 210mm)
    'y_axis': (0.0, 0.297),         # Y축 정의점 (왼쪽 위, 297mm)
}
```

### 시각적 배치

```
A4 용지 (210mm × 297mm)
━━━━━━━━━━━━━━━━━━━━━━━
┃                      ┃
┃  Y-axis             ┃ 297mm
┃  (0, 297mm)         ┃
┃  ●                  ┃
┃  ┃                  ┃
┃  ┃                  ┃
┃  ┃                  ┃
┃  ┃                  ┃
┃  ●━━━━━━━━━━━━━━━●  ┃
┃  Origin         X-axis
┃  (0,0)      (210mm,0) ┃
━━━━━━━━━━━━━━━━━━━━━━━
    210mm
```

## 📝 캘리브레이션 절차

### Step 1: 카메라 초점거리 캘리브레이션
```bash
1. A4 용지를 1.5m 거리에 놓기
2. 's' 키 누르기
3. FOCAL_PX 값 저장됨
```

### Step 2: 평면 좌표계 캘리브레이션
```bash
1. 'c' 키 누르기 (캘리브레이션 시작)
2. A4 용지의 왼쪽 아래 모서리 클릭 (원점)
3. A4 용지의 오른쪽 아래 모서리 클릭 (X축)
4. A4 용지의 왼쪽 위 모서리 클릭 (Y축)
```

### Step 3: 평면 좌표 확인
```bash
1. 'p' 키 눌러 평면 좌표 표시 활성화
2. 화면에 다음 정보 표시:
   - X(on plane): 0.0000 ~ 0.2100 m (0 ~ 210mm)
   - Y(on plane): 0.0000 ~ 0.2970 m (0 ~ 297mm)
   - Status: IN RANGE / OUT OF RANGE
```

## 🎓 X값이 같다는 것을 확인하는 방법

### 방법 1: 선을 따라 이동
```
1. A4 용지에 수평선 그리기 (예: Y=100mm 위치)
2. 물체를 그 선을 따라 좌우로 이동
3. 평면 좌표의 Y값이 일정하게 유지되는지 확인
   → Y ≈ 0.100 m (100mm)
```

### 방법 2: 여러 점 측정
```python
# 같은 수평선상의 점들
Point A: (50mm, 100mm)   → 평면 좌표: X=0.050, Y=0.100
Point B: (100mm, 100mm)  → 평면 좌표: X=0.100, Y=0.100
Point C: (150mm, 100mm)  → 평면 좌표: X=0.150, Y=0.100

# Y값이 모두 0.100으로 동일 → 같은 선상에 있음을 확인
```

### 방법 3: 격자 패턴 사용
```
A4 용지에 10mm 간격 격자 그리기:

Y=200mm  ─────────────────
         │ │ │ │ │ │ │ │
Y=190mm  ─────────────────
         │ │ │ │ │ │ │ │
Y=180mm  ─────────────────
         ...

각 수평선마다 Y값이 일정한지 확인
```

## 🔍 정확도 향상 팁

### 1. **정밀한 마킹**
```bash
- A4 용지 모서리에 작은 점을 정확하게 표시
- 펜으로 ● 마크 그리기
- 가능하면 스티커나 색상 마커 사용
```

### 2. **조명 조건**
```bash
- 균일한 조명
- 그림자 최소화
- 반사 방지
```

### 3. **카메라 각도**
```bash
- 가능한 한 용지와 평행하게
- 기울어진 각도는 왜곡 증가
- 권장: ±15도 이내
```

### 4. **용지 평평하게 유지**
```bash
- 용지가 휘어지면 정확도 감소
- 딱딱한 판에 고정 권장
- 테이프나 클립으로 고정
```

## 📊 Homography 변환 원리

### Affine 변환 행렬
```
[x']   [a  b  c]   [x]
[y'] = [d  e  f] × [y]
[1 ]   [0  0  1]   [1]

여기서:
- (x, y): 픽셀 좌표
- (x', y'): 평면 좌표 (미터)
- a, b, c, d, e, f: 변환 파라미터 (3점으로부터 계산)
```

### 코드 구현
```python
# 3점으로 Affine 변환 계산
src_pts = [(x1_px, y1_px), (x2_px, y2_px), (x3_px, y3_px)]  # 픽셀
dst_pts = [(0, 0), (0.210, 0), (0, 0.297)]                   # 미터

homography_matrix = cv2.getAffineTransform(src_pts, dst_pts)

# 임의의 점 변환
point_px = (center_x_px, center_y_px)
point_m = homography_matrix @ [point_px[0], point_px[1], 1.0]
# → (x_m, y_m)
```

## 🧪 검증 방법

### 테스트 1: 알려진 위치 확인
```bash
1. 물체를 정확히 (100mm, 150mm) 위치에 놓기
2. 측정된 평면 좌표 확인
3. 오차 계산: error = |measured - actual|
4. 허용 오차: ±2mm 이내
```

### 테스트 2: 반복성 테스트
```bash
1. 같은 위치에 물체를 5번 놓기
2. 각각 측정
3. 표준편차 계산
4. 표준편차 < 1mm 이면 양호
```

### 테스트 3: 경계 테스트
```bash
1. 4개 모서리 각각 측정
2. 예상값과 비교:
   - (0, 0)
   - (210mm, 0)
   - (0, 297mm)
   - (210mm, 297mm)
```

## 🎬 실제 사용 예시

### 예제 1: 로봇 픽앤플레이스
```python
# 물체 위치 감지
plane_x, plane_y = 0.105, 0.148  # 105mm, 148mm

# 모터 제어로 이동
move_to_position(plane_x * 1000, plane_y * 1000)  # mm 단위
```

### 예제 2: 품질 검사
```python
# 정확한 위치에 있는지 확인
target_x, target_y = 0.100, 0.150  # 목표 위치
measured_x, measured_y = get_plane_coords()

error_x = abs(measured_x - target_x)
error_y = abs(measured_y - target_y)

if error_x < 0.002 and error_y < 0.002:  # 2mm 이내
    print("위치 정확!")
else:
    print(f"오차: X={error_x*1000:.1f}mm, Y={error_y*1000:.1f}mm")
```

## 💡 고급 팁

### 다중 카메라 사용
```bash
- 여러 각도에서 촬영
- 각 카메라마다 독립적으로 캘리브레이션
- 3D 재구성 가능
```

### 동적 추적
```bash
- EMA 필터로 지터 제거
- 칼만 필터로 예측
- 속도/가속도 계산 가능
```

### 왜곡 보정
```bash
# 카메라 왜곡 보정 (선택사항)
mtx, dist = cv2.calibrateCamera(...)
frame = cv2.undistort(frame, mtx, dist)
```

## 🔑 핵심 포인트 요약

1. **3점 = 최소 요구사항**
   - 원점: 좌표계 시작점
   - X축점: X방향 정의
   - Y축점: Y방향 정의

2. **정확한 마킹이 핵심**
   - 모서리를 정확히 찾기
   - 가능하면 마커 사용

3. **검증 필수**
   - 알려진 위치로 테스트
   - 반복 측정으로 신뢰도 확인

4. **X값이 같음 = 같은 Y 선상**
   - 평면 좌표계에서 X가 일정 → 수직선
   - Y가 일정 → 수평선


